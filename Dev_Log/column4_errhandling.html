<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TelpCamp 開発記録 - コラム: エラー処理の舞台裏</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }

        h1,
        h2,
        h3,
        h4 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        h4 {
            border-bottom: none;
            color: #3498db;
        }

        code {
            background-color: #ecf0f1;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }

        pre {
            background-color: #2c3e50;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        .step {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .concept {
            background-color: #e8f6f3;
            border-left: 5px solid #1abc9c;
            padding: 15px;
            margin: 20px 0;
        }

        .flowchart {
            background-color: #f5f5f5;
            border: 1px solid #ccc;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre;
        }

        li {
            margin-bottom: 10px;
        }
    </style>
</head>

<body>

    <h1>TelpCamp プロジェクト作成の記録</h1>

    <div class="step">
        <h2>コラム: Expressエラー処理の舞台裏 - プログラムの流れを徹底解剖！</h2>
        <p>
            前回のエラーハンドリング実装では、<code>wrapAsync</code>や<code>ExpressError</code>、そして特別な<code>app.use()</code>を導入しました。これらが連携することで、クリーンで強力なエラー処理が実現できます。
        </p>
        <p>
            今回は、この仕組みが内部でどのように動いているのか、物語の登場人物になぞらえて、その流れを詳しく見ていきましょう！
        </p>

        <h3>物語の登場人物たち</h3>
        <p>私たちのエラー処理の物語には、主に4人の登場人物がいます。</p>
        <ul>
            <li><strong>ルートハンドラ (各ルートの<code>async (req, res) => { ... }</code>)</strong>:
                <br>「現場作業員」。データベースからデータを取ってきたり、ページをレンダリングしたりと、本来の仕事を担当します。
            </li>
            <li><strong><code>wrapAsync</code>関数</strong>:
                <br>「監視役」。現場作業員（ルートハンドラ）の仕事ぶりをじっと見守っています。
            </li>
            <li><strong><code>next()</code>関数</strong>:
                <br>「伝令役」。何か問題が起きたときに、次の担当者へその情報を伝える役割を持ちます。
            </li>
            <li><strong>中央エラーハンドラ (<code>app.use((err, req, res, next) => { ... })</code>)</strong>:
                <br>「司令塔」または「病院」。伝令役からエラーの報告を受け、最終的な対応（ユーザーへのエラー表示など）を決定・実行します。
            </li>
        </ul>

        <h3>シナリオで追う！エラー発生から処理までの道のり</h3>
        <p>では、実際のコードがどのように動くのか、2つのシナリオで見てみましょう。</p>

        <div class="concept">
            <h4>シナリオ1：予期せぬ事故！（非同期エラーが発生した場合）</h4>
            <p>
                例えば、<code>POST /campgrounds</code>で新しいキャンプ場を保存しようとしたとき、データベースの接続が切れていて<code>await campground.save()</code>が失敗したとします。
            </p>
            <pre><code>// 監視役(wrapAsync)が現場作業員(async関数)を見守っている
app.post('/campgrounds', wrapAsync(async (req, res, next) => {
    const campground = new Campground(req.body.campground);
    // ここで事故発生！Promiseがrejectされる
    await campground.save(); 
    res.redirect(`/campgrounds/${campground._id}`);
}));</code></pre>

            <p>この時、プログラム内部では以下のドラマが繰り広げられます。</p>
            <ol>
                <li><strong>事故発生</strong>:
                    現場作業員(<code>async</code>関数)の<code>await campground.save()</code>が失敗し、エラーを投げます（Promiseがrejectされます）。
                </li>
                <li><strong>監視役がキャッチ！</strong>:
                    現場作業員を包んでいる監視役(<code>wrapAsync</code>)の<code>.catch(e => next(e))</code>が、このエラー(<code>e</code>)を即座に捕まえます。
                    <pre><code>// wrapAsyncの中身
function wrapAsync(fn) {
    return function (req, res, next) {
        // 現場作業員(fn)を実行し、エラーが出たら.catchで捕まえる
        fn(req, res, next).catch(e => next(e));
    }
}</code></pre>
                </li>
                <li><strong>伝令役、走る！</strong>:
                    監視役は捕まえたエラー(<code>e</code>)を、伝令役(<code>next</code>)に渡して「司令塔に報告してくれ！」と命令します。これが<code>next(e)</code>です。
                </li>
                <li><strong>司令塔へ直行</strong>:
                    Expressは、<strong>引数付きで<code>next()</code>が呼ばれた</strong>ことを検知すると、通常のルート処理をすべて中断し、引数が4つある特別なミドルウェア、つまり司令塔（中央エラーハンドラ）を探し始めます。
                </li>
                <li><strong>司令塔、対応開始</strong>:
                    司令塔は伝令役からエラー(<code>err</code>)を受け取り、状況に応じた対応（ステータスコード500でエラーメッセージを送信）を開始します。
                    <pre><code>app.use((err, req, res, next) => {
    // 伝令役から渡されたエラー(err)を受け取る
    const { statusCode = 500, message = '問題が起きました' } = err;
    res.status(statusCode).send(message);
});</code></pre>
                </li>
            </ol>
            <p>この一連の流れのおかげで、私たちは各ルートに<code>try...catch</code>を書かなくても、エラーが自動的に司令塔に集められるのです！</p>
        </div>

        <div class="concept">
            <h4>シナリオ2：意図的な警告（自分でエラーを通知する場合）</h4>
            <p>
                次に、<code>GET /campgrounds/:id</code>で、存在しないIDが指定された場合を考えます。これはデータベースのエラーではなく、「データが見つからなかった」というアプリケーション上のエラーです。
            </p>
            <pre><code>app.get('/campgrounds/:id', wrapAsync(async (req, res, next) => {
    const campground = await Campground.findById(id);
    if (!campground) {
        // 現場作業員が自ら伝令役を呼ぶ！
        return next(new ExpressError('指定されたIDのキャンプ場は見つかりませんでした。', 404));
    }
    res.render('campgrounds/show', { campground });
}));</code></pre>
            <ol>
                <li><strong>状況判断</strong>:
                    現場作業員(<code>async</code>関数)は、<code>campground</code>が<code>null</code>であることに気づきます。</li>
                <li><strong>伝令役を呼ぶ！</strong>:
                    現場作業員は「司令塔に『見つからない(404)』と報告してくれ！」と、自ら伝令役(<code>next</code>)を呼び出します。このとき、<code>ExpressError</code>という専用の報告書（メッセージとステータスコード入り）を渡します。
                </li>
                <li><strong>司令塔へ直行</strong>: シナリオ1と同様、引数付きで<code>next()</code>が呼ばれたので、Expressは司令塔（中央エラーハンドラ）へ処理を移します。
                </li>
                <li><strong>司令塔、報告書に基づき対応</strong>:
                    司令塔は、渡された報告書(<code>ExpressError</code>オブジェクト)から<code>message</code>と<code>statusCode</code>(404)を正確に読み取り、ユーザーに「指定されたIDのキャンプ場は見つかりませんでした。」と伝えます。
                </li>
            </ol>
        </div>

        <h3>まとめ：この仕組みがもたらす価値</h3>
        <p>
            この「監視役がエラーを捕まえて伝令役に渡し、司令塔が集中処理する」という仕組みは、プロの現場で広く使われている堅牢な設計です。
        </p>
        <ul>
            <li><strong>DRY (Don't Repeat Yourself)</strong>: 各ルートに同じような<code>try...catch</code>を書く必要がなくなり、コードがスッキリします。
            </li>
            <li><strong>関心の分離</strong>: 現場作業員（ルートハンドラ）は自分の仕事に集中でき、エラー処理のことは司令塔に任せられます。</li>
            <li><strong>メンテナンス性の向上</strong>: エラー時の挙動（例:
                エラーログをファイルに書く、開発者にメールを送る）を変更したくなったとき、修正箇所は司令塔（中央エラーハンドラ）の1箇所だけで済みます。</li>
        </ul>
        <p>
            一見複雑に見えたかもしれませんが、それぞれの役割と情報の流れがわかると、非常に合理的で美しい仕組みであることがお分かりいただけたかと思います。この理解は、今後の開発で必ず役立ちます！
        </p>
        <h3>もう一度整理！エラー処理の全体像</h3>
        <p>ここまでの内容を、役割分担としてもう一度整理してみましょう。</p>
        <div class="flowchart">
            リクエスト発生
            ↓
            マッチするルートを探す
            ↓
            【ルートハンドラ（現場作業員）が処理を開始】
            │
            ├─&lt;成功&gt;──→ res.render() や res.redirect() で応答を返す【完了】
            │
            ├─&lt;意図的なエラー&gt;──→ `new ExpressError()`で報告書を作成し、`next()`で伝令役に渡す
            │ (例: データが見つからない) │
            │ ↓
            └─&lt;予期せぬエラー&gt;──→ `wrapAsync`(監視役)がエラーを捕まえ、`next()`で伝令役に渡す
            (例: DB接続断) │
            ↓
            【中央エラーハンドラ（司令塔）が報告を受け取る】
            ↓
            報告書(errオブジェクト)の内容を確認
            ↓
            `res.status()`でステータスコードを設定し、エラーメッセージを返す【完了】
        </div>

        <h3>HTTPステータスコードと`res.status()`の重要性</h3>
        <p>
            司令塔（中央エラーハンドラ）がエラーを返す際に使っている<code>res.status(statusCode).send(message)</code>も重要な役割を担っています。
        </p>
        <p>
            サーバーからブラウザへの応答は「小包」のようなものです。<code>res.send()</code>で送るメッセージは「中身」にあたります。そして、その小包には「送り状」が貼られており、そこには「このリクエストは成功したか(200
            OK)」「ページが見つからなかったか(404 Not Found)」「サーバー内部で問題が起きたか(500 Internal Server
            Error)」といった結果を示す<strong>ステータスコード</strong>が書かれています。
        </p>
        <p>
            <code>res.status(statusCode)</code>は、この「送り状」に適切なステータスコードを書き込むための命令です。
        </p>
        <p>
            これにより、ブラウザはただエラーメッセージを受け取るだけでなく、「どのような種類のエラーが起きたのか」を正しく理解できます。これは、ブラウザの開発者ツールでエラーの原因を特定したり、将来的により高度なフロントエンド処理（例:
            401エラーならログインページに飛ばす）を実装したりする上で不可欠な情報となります。
        </p>
        <p>
            つまり、ステータスコードは、サーバーとクライアント間の「対話」を円滑にするための、非常に大切な共通言語なのです。
        </p>
    </div>

</body>
</div>

</body>

</html>