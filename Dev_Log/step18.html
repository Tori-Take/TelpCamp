<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TelpCamp 開発記録 - Step 18: レビュー機能のモデル設計</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }

        h1,
        h2,
        h3,
        h4 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        h4 {
            border-bottom: none;
            color: #3498db;
        }

        code {
            background-color: #ecf0f1;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }

        pre {
            background-color: #2c3e50;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        .step {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .concept {
            background-color: #e8f6f3;
            border-left: 5px solid #1abc9c;
            padding: 15px;
            margin: 20px 0;
        }
    </style>
</head>

<body>

    <h1>TelpCamp プロジェクト作成の記録</h1>

    <div class="step">
        <h2>Step 18: レビュー機能のモデル設計 - リレーションシップの応用</h2>
        <p>
            いよいよ、このアプリケーションの核となる「レビュー機能」の実装に着手します。
            今回は、<code>farmstand</code>プロジェクトで学んだリレーションシップの知識を応用し、レビュー機能の土台となるモデルとスキーマを設計・実装します。
        </p>

        <h3>学習の目的</h3>
        <ul>
            <li>新しい機能（レビュー）のための新しいMongooseモデルを作成する方法を実践する。</li>
            <li>キャンプ場（親）とレビュー（子）の間に「1対多」のリレーションシップを構築する。</li>
            <li>Mongooseミドルウェア（<code>post</code>フック）を使い、親ドキュメントが削除されたときに関連する子ドキュメントも自動的に削除する「カスケード削除」を実装する。</li>
        </ul>
    </div>

    <div class="step">
        <h2>実装の解説</h2>
        <p>
            スキーマ設計として、キャンプ場とレビューは「1対多」の関係になります。一つのキャンプ場には、複数のレビューが紐付きます。
            今回は、<code>Campground</code>モデルが<code>Review</code>モデルのIDを配列として保持する「親から子への参照（Parent-Referencing）」パターンを採用します。
        </p>
        <ol>
            <li>
                <h4>1. レビューモデルの新規作成 (<code>models/review.js</code>)</h4>
                <p>
                    まず、レビューのデータ構造を定義するための、新しいスキーマとモデルを作成します。レビュー本文（<code>body</code>）と評価（<code>rating</code>）の2つのフィールドを持つシンプルな構成です。
                </p>
                <pre><code class="language-javascript">const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const reviewSchema = new Schema({
    body: String,
    rating: Number
});

module.exports = mongoose.model('Review', reviewSchema);</code></pre>
            </li>
            <li>
                <h4>2. キャンプ場モデルの修正 (<code>models/campground.js</code>)</h4>
                <p>
                    次に、既存の<code>Campground</code>モデルを修正し、レビューとの関連付けと、データの整合性を保つための重要な仕組みを追加します。
                </p>

                <h5>リレーションシップの追加</h5>
                <p>
                    <code>CampgroundSchema</code>に、レビューのIDを格納するための<code>reviews</code>配列を追加します。
                </p>
                <pre><code class="language-javascript">const CampgroundSchema = new Schema({
    // ... 他のフィールド
    reviews: [
        {
            type: Schema.Types.ObjectId,
            ref: 'Review' // 'Review'モデルを参照することをMongooseに伝える
        }
    ]
});</code></pre>
                <div class="concept">
                    <h4>💡 親から子への参照 (Parent-Referencing)</h4>
                    <p>
                        この設計は、親ドキュメント（<code>Campground</code>）が、子ドキュメント（<code>Review</code>）のIDのリストを持つパターンです。
                        <code>ref: 'Review'</code>と指定することで、Mongooseの<code>populate()</code>メソッドを使って、このIDのリストを実際のレビューデータに簡単に置き換えることができます。
                    </p>
                </div>

                <h5>カスケード削除の実装</h5>
                <p>
                    キャンプ場が削除された場合、それに紐づくレビューもデータベースから削除されなければ、不要なデータ（ゴミデータ）が残ってしまいます。
                    この問題を解決するため、<code>farmstand</code>プロジェクトでも学んだMongooseミドルウェア（<code>post</code>フック）を使って、連鎖的な削除（カスケード削除）を実装します。
                </p>
                <pre><code class="language-javascript">// Campgroundが削除されたら、関連するReviewも削除するミドルウェア
CampgroundSchema.post('findOneAndDelete', async function (doc) {
    if (doc) {
        await Review.deleteMany({
            _id: {
                $in: doc.reviews
            }
        });
    }
});</code></pre>
                <div class="concept">
                    <h4>💡 エレガントな後処理: <code>post</code>ミドルウェア</h4>
                    <p>
                        このコードは、「<code>findOneAndDelete</code>（または<code>findByIdAndDelete</code>）という操作が完了した**後**に、この関数を自動で実行せよ」というMongooseへの予約です。
                    </p>
                    <p>
                        関数の引数<code>doc</code>には、削除されたキャンプ場のドキュメントが自動的に渡されます。そのため、<code>doc.reviews</code>でそのキャンプ場が持っていたレビューIDの配列にアクセスできます。
                        そして、<code>deleteMany</code>と<code>$in</code>演算子を使い、そのIDリストに合致するレビューを<code>reviews</code>コレクションから一括で削除しています。
                    </p>
                    <p>
                        この方法により、ルートハンドラ側はキャンプ場を削除する処理に集中でき、関連データのクリーンアップはモデル自身が責任を持って行ってくれます。これは、コードの関心を分離し、メンテナンス性を高める非常に優れた設計パターンです。
                    </p>
                </div>
            </li>
        </ol>
    </div>

</body>

</html>